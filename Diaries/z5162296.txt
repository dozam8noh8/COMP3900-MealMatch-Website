
Week 1
The group was formed and a decision on the project (MealMatch) and tools to be used was made. I joined the team on Jira and the GitHub repository. In doing some research, I came across Recipeland and Foodwise, two other systems which have a functionality similar to our specs, and listed their pros and cons. I also attended the group meeting during which I helped come up with epics and smaller user stories.

Week 2
At the beginning of the week, I drew up draft storyboards, which I shared with the rest of the group. When we had our group meeting, we checked to ensure that all our user stories were covered. I noted down a few changes to be made and added the final storyboards to our proposal.

Week 3
This week I helped finished off our proposal for submission as we marked the start of our first sprint. I have been learning Angular as I go along and have thus been able to work on a core user story for Epic 2, which is the search for an ingredient by typing into a search bar. 
Our database has not been set up at this point so I placed dummy data in the frontend to produce a usable interface for the time being. Since this did not take as long as expected, I decided to start working on the addition and removal of ingredients from a user's input list. 
Next week I hope the API to our backend will be set up so that I can make calls to obtain data from our database.

Week 4 
At the beginning of this week, I found the external API Spoonacular, which seemed very useful for our needs. Since we wanted to store data in our own database, I thought maybe we could scrape from this API. I believed we should have a uniform idea throughout the team of the schemas we would store. So I drew up an ER diagram of what I had in mind and shared it with the group. A possible legal issue was brought to my attention by a team member which was that the Terms of Service of Spoonacular forbids any form of scrape and storing of their data. As a result, my team decided to find another external API to use. One thing I was unsure of was how we would store the instructions for our recipes. My initial thought was that if we could maintain the order of steps in our database, then it could be easily integrated with a user experience I had in mind for the editing of recipes. However, I think we decided to just go with a long string/varchar, at least for now.
I have also been looking into Angular more and recognised that I could improve some of my code from last week, making it more decoupled. I refactored some of the implementation for recipe searching and list maintenance to utilise an Angular service. Additionally, I decided to pick up on another user story for Epic 2. On the frontend, I implemented ingredient browsing by category using the same service to ensure data is synchronised i.e. if an ingredient was searched and added to the list, it should also be checked off in the category component and vice versa.
I started learning about the HttpClient module and at the same time, the backend team had set up API endpoints to retrieve data from our database. As a result, I replaced the dummy data I had in the frontend with calls to our backend. 
I am now working on displaying the results of a search and the page for each recipe's details, which I hope to finish next week.

Week 5
This week as started to work on another user story for Epic 2 and that was the actual search functionality. Using an endpoint set up by our backend team, I was able to send a post request with a JSON body of all input ingredients and display the results. I then started to work on the page that displays recipe details. I find that it would make most sense to also have an endpoint that gets the details of a recipe when given an id. Since this had not been set up, I observed the backend code and added a simple endpoint, which may still be subject to some change. But at least for now, I was able to get data to display on the frontend. The UI at the moment is quite basic, but I hope it will be improved in the next sprint, along with a few other things for which I created subtasks under E2S5.
With our demo coming up, I shifted my attention back to the user stories I had already completed this sprint. I noticed that at times when an ingredient was selected, it wouldn't be added to the end of the list. I added a subtask under E2S2 but was able to quickly fix this. I also added another task which I believe could help improve UX and that is to ensure that the inputted ingredients are persisted in some way so that they don't disappear if the user refreshes the page or opens a new tab. This may require some more work and has not yet been completed.
We had a brief meeting with a few members of the team to see how everyone was going and what we could demo. It was suggested that our categories and ingredients could be displayed in a more relevant order. For the time being, I made a quick adjustment in the back end to cater for this, but I think maybe it could be done in a better way. Since it takes a while for our API to return data, a team member suggested that perhaps we could have some dummy data in place initially. This would make our web app appear more responsive.
Another team member noticed that they could not go through the search autocompleted options using the keyboard. This would also improve UX and so I made a fix for that. I also ensured that the search is case insensitive and that some text would be displayed to indicate when the ingredient list is empty.
After our demo, which I think went quite well, we had our retrospective and then planned for the next sprint. In addition to continuing to work on search results and recipe details page, I will also be implementing the filtering of recipes by meal type.

Week 6
One thing that we agreed upon last week was that we should have better error-handling on the frontend such that users would be informed of if/when an API call fails. 
I wasn’t too sure of the right approach for this. I had read that HttpClient.get returns an Observable which could be subscribed to. The subscribe method could then take in two functions, one for the successful retrieval of data and the other in the event of an error. But I think I struggled with how this should be passed down to the ingredient search and ingredient by category component, since the get requests were called in a share service. 
I thought that this would be a good instance for me to ask for early feedback from other team members, which was the to-do I put down and assigned myself to. Whilst changes were made, at the time of writing, this issue has not been completely resolved yet.
Another thing I noticed from my work last sprint was that after pressing back to results from a recipe page, the results would disappear. I think the issue was that I was calling the search API endpoint in ngOnInit. This initialiser and the constructor seem to be called every time a page is appears in view and so by pressing back (as opposed to submitting a query from the home page), no search ingredients are passed in for results to be returned. I think I have been able to fix this by adding a search service which would persist the results from the last search.
I've also managed to get the filtering of recipes by meal type to work. What this required was maintaining a property mealType and just ensuring that only recipes that pertain to this meal type are displayed. I made sure that this property could also be set alongside a user’s input ingredient list, if they choose to do so.

Week 7
With some research, I learnt that data could be stored in a global variable called localStorage in Angular. This allowed me to implement the persistence of a user’s input list of ingredients over sessions. The list is no longer cleared after refreshing. I had to make sure that when the locally stored data is loaded, those ingredients would be checked off under their categories. There wasn’t any issues with this checking off, if a user decides to remove an ingredient that had been preloaded, it wouldn’t be unchecked. So this is a bug that I will create a task for and should be fixed.
One of the user stories I’d been assigned for this sprint is the creation of a recipe. Based on our story boards, users can add slots where they type for an ingredient and have autocomplete, similar to our search bar on the home page. 
I was hoping to be able to reuse the same component, but realised that some of its functionality was tightly coupled with the maintenance of search ingredients from the home page i.e. the autocompletion is based on what ingredients had been added on the home page meaning if we are creating a recipe and some ingredients won’t be visible for adding. Whilst I think that it would be beneficial to eventually refactor this, I was quite busy this week and it was quicker for me to just based some of the code on the old component.
There was then the case of adding a new ingredient. What I had in mind was to have a drop down selection of categories next to a slot. If the user had entered an existing ingredient, then the drop down would be disabled. If the user had entered something that was not an existing ingredient, then they could have the option of assigning a category. However, I struggled to implement this. 
I think for me, it was the uncertainty of what data should be maintained in what component. Whether each slot (child component) should have an associated Ingredient or just a string, or both.
As a result, I decided to discuss with my team members how they think the addition of a new ingredient could work. They suggested having a pop up dialog, which I thought was a good idea. So I proceeded to implement that.
The frontend for creating a new ingredient has now been set up, but calls to our API still need to be made and the UI is very basic. There is a chance we may move to use to use Bootstrap instead of Angular Material, which I would like to discuss in our upcoming meeting.

Week 8
For the beginning of this week, I was again quite busy. I was able to implement the upload of an image for a recipe, utilising one of the components implemented by Owen, which he also used for profile image upload. What was interesting to note, was in order to upload an image for a recipe, a recipeID needs to be associated, so what I had to do was call the image upload endpoint within the request to create a recipe so that an ID could be obtained. Whilst I don't think this is an issue with our project, if there were more layers, there would be the potential for "callback hell".
Aside from that, I helped confirm the Jira user stories that we would presenting for our demo and attended group meetings where we prepared. We came across quite a few bugs during our run throughs and some of which were attributed to the changes and implementations I made last week. God bless Owen and his hard work in going through my code and fixing quite a few of them before the demo.
Some of the changes he made are in accordance to my implementations, although there is great room for improvement in terms of how I'd done some things. Owen suggested that interfaces could be made to correspond with the JSON responses received from our API, for example, an Ingredient shouldn't have onList as an attribute, but perhaps it could be extended to do so.
The demo once again went well and we had our retrospective soon after. The issues mentioned above along with a few others were noted. I believe I was able to carry out my action item from last retro in that I asked for feedback soon after I'd implemented things, however, bugs were still relatively late to be discovered. I made an action item to try and reduce dependencies and improve our code, although, this may not really be a primary focus for our next sprint.
Towards the latter half of the week, I sort of had a pair programming session with Owen, so that I could explain some of the code I'd written. We were able to resolve a bug or two in that time. 
I also realised that the filtering of mealtypes was still using a hardcoded array of string so I changed them to receive the data from API calls. 
Owen mentioned that it be preferable for users to be able to see the images they upload for a recipe, so I also got onto this task. Again a recipe needed an ID before an image could be associated and uploaded to our server, so I couldn't post the image and get a URL to display the image. I did some research online and found a solution, which require some small modification of the upload component made by Owen.
Seeing as the backend for ingredient recommendation had been completed, I've decided to claim the task of implementing the frontend.


Week 9
Over the weekend I finished off implementing the frontend for the recommendations and the previewing of recipe images in editing the recipe.
I also managed to make the search bar more generic with the goal of being able to reuse it. Whilst I was able to use this freshly decoupled component on the home page, when it came to using it on the recipe form, there was more dependencies on this end. But perhaps one day, that can be refactored.
With the code submission being due on Friday, this week was crunch time. 

There were quite a few bugs and small things that needed to be resolved which I made into Jira tasks so I wouldn’t forget. I had noted that users probably shouldn’t be able to access the url ‘/search’ by typing it in. A team member’s fix for this was to check if a searchState is passed in before displaying the search results page. However, when a user presses the back button, a state isn’t passed in, resulting in them not being able to go back to their search results. I though this should be changed back so I looked for an alternative solution. I found that Angular’s Router can check whether a page was navigated. Using this, I was able to redirect a user away only when they type in ‘/search’.
There was a side issue in that, the website was being reloaded when a recipe view card was selected. This could be seen from the console and also a brief second of complete white page when a recipe is being loaded. It also caused issues for my solution to the previous issue. I was able to resolve this by changing around how routes were linked within the recipe view card.

Another small issue was that upon a second search, the user would briefly see the results of their previous search before the new results come in. This is because after the first search, in the searchService, the results would be maintained with searchComplete being set to true and just remaining true. To fix this, I just need to ensure that whenever search was called, searchComplete would first be set to false.

I also realised that from my early implementation of filtering by meal type, I had used some dummy data as the endpoint had not yet been set up. This was simply changed by adding a function in searchService which could be used to call the API. However, I found it a bit off-putting going from the search page to results and from recipe view page back to results, with my selected meal type disappearing. Thus, I decided to maintain the last selected meal type in the search service so it could be retrieved again.

Our app was also just displaying an empty template on ‘/recipe/<id>’ when the id was invalid or non-existing. Thus, I altered this by checking that id was indeed a number and that our API returned valid data. Initially, it was done by checking if the object had keys i.e. not empty, however due to some changes to the back end where an error is raised, this is now handled in the error function supplied to the subscription to our API call.

One bug that was found on the recommended ingredients feature I implemented was that adding an ingredient from this section would not result in it being ticked off. I figured a good solution to this would be, rather than taking in a reference to an Ingredient object, the addToList function (in ingredientService) should just take in an ingredient ID and only add if an ingredient with such ID is not already on the list.
There was also another issue associated with this feature in that if a user spammed added an ingredient, it would appear on the input list multiple times. This is because the list of recommended ingredients only change once the results from the API call come in. Originally I had considered whether to put a spinner for every time the user adds/removes an ingredient and the API call was made, however thought this would detract from the user experience. 
Whilst I had interfaced with Observables from the Angular RxJS library in using HttpClient, I was informed that implementing my own could help solve the issue. Rather than the service returning a static list of ingredients, the list would be emitted as an Observable. I then keep a list of recommended ingredients in our display component, so that items can be removed from view. Meanwhile if a new set is emitted from the service, this list would be updated to reflect that.

Alongside these fixes, our scrum master also wanted to incorporate some other novel features. One of these included the ability for users to review (rate and comment on) a recipe. Our backend was set up such that a user can only have one rating and comment per recipe and so the frontend needed to reflect that. I considered that users if users hadn’t rated a recipe yet, a form should be displayed and if they had, then they should be able to edit their own reviews made visible to them at the top. The process of getting data and displaying it under conditions was familiar enough to me at this stage. 
But what was interesting was the actual star-rating functionality that I had in mind. I had just begun to partially implement it from scratch, when I realised it may be more complicated than I thought, so I started to look for a third-party library. I came across the Angular Bootstrap rater, which functioned very well. Stars could also be partially filled for the displaying of the average rating for a recipe. 
However, once installed our UI was affected due to Angular Bootstrap’s styling overriding our original. A team member help find that this could be fixed by commenting out some lines of ng-boostrap’s SCSS file. We would just need to include these instructions in our guide for setup and configuration.

When we were checking the specifications again, we realised that contributors should be able to add instructions in steps, rather than as a chunk of text. So the backend for recipe creation and editing was changed and I did the same for the front end. I thought that a good user experience should allow users to reorder the steps they enter and so using the drag and drop component from Angular Material’s CDK, I was able to implement this. We then decided to also make the ingredients reorderable. 

Once this was done, we began to do extensive testing our application. I actually ask an outsider to try our app out and a few things that are simple enough were brought up. This included clearer labelling of the user’s profile image on their dashboard and being able to delete reviews. I also decided that if a user was on the view page for a recipe they own, they should be able to navigate from there to edit the details of their recipe.

With our deadline being extended, every team member will continue to QA our site and if we could get an endpoint for deleting reviews I will add that our review system.


Week 10
Since it was very hard to find recipes that match exactly the ingredients a user has, results always seemed to look a bit empty. Because of this, we thought it would be a good idea to implement partial matching as well, so that users can see what recipes they could make if they had some more ingredients. After the backend was modified to return the appropriate data, I made sure this information, including the ingredients that are missing for each recipe, is displayed on the frontend. I added a button with a tooltip to inform users that they can toggle between fully matched and partially matched results.
I also added the removal of reviews to the frontend since our API had been updated.
The rest of my week was spent working on the report. Since the feedback for our proposal from last time said it wasn't completely clear how we were meeting the project objectives, I decided to explicitly list the objectives and give a description underneath each. I also gave a brief summary of how to use our functionalities, which was expanded upon by another team member. I also made sure to talk about the implementation challenges that I faced.
Before submission, I also just formatted a lot of our text, added in a table of contents and cover page.
I am quite happy with the final result of our project. Starting this semester with barely any knowledge of Angular, I have been introduced to many new programming concepts and paradigms that I hope to continue to learn more about.
I would also say that this project is one of the most positive group work experiences I have had.